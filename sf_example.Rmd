---
title: "Intro to R: Geospatial work with the sf package"
author: "Donny Keighley"
output: html_document
---

Alot of the things we do every day in the oil and gas industry are spatial in nature.  In fact most of them can be automated without much work if you know how.  I've automated well spacing calculations, sticking up acreage, creating operatorship maps, and projecting surveys to name a few.  Recently I've relied on the sf package in R to do this.

sf stands for "Simple Features" and is a relatively new R package.  Simple features are basically just a condensed way to describe shapes from points to lines to polygons.  The package lets you do basic GIS functions with these features like transform coordinates, intersect shapes, calculate distances, and create buffer polygons.

It's probably easier to just show you a few things it can do and hopefully that will give you a flavor of what's possible so you can explore more on your own.

Let's get started!  We'll start with some simple density calculations that are a version of something I use all the time.  But first, let's install the package like you would any other package:

```{r, install package, eval=FALSE}
install.packages('sf')
```

And load it like this:

```{r, load package, message=FALSE}
library(sf)
```

Next, let's download a free shapefile to work with.  In this case, the well spots and lines from the COGCC.

```{r, download wells, eval=FALSE}
link = 'https://cogcc.state.co.us/documents/data/downloads/gis/DIRECTIONAL_LINES_SHP.ZIP'
destination = paste0(getwd(), '/', basename(link))
download.file(url=link, destfile = destination, mode='wb')
unzip(destination, exdir=getwd())
unlink(destination)
```

Hopefully that works on non-Windows machines.  If not, just download and unzip the file like normal and put it in your current working directory.  Your working directory is the default place R looks for files.  Don't know your current working directory path?  Look it up like this:

```{r, getwd}
getwd()
```

Now let's get to the fun.  First we'll import our shapefiles to R.  As you'll see, most of the function names in the sf package begin with st_ and are pretty well named.  We'll use st_read to import the shapefiles.  You can see all the functions available in the [manual](https://cran.r-project.org/web/packages/sf/sf.pdf).

```{r, import shapefiles, message=FALSE}
wells = st_read(paste0(getwd(), '/Directional_Lines.shp'))
```

We now have a simple features collection (sfc) called wells.  Here's what the first 5 rows of it look like:

```{r, show well}
head(wells, 5)
```

If you've used R before, you'll notice it looks pretty much like a data.frame... and it is!  Filtering, merging, indexing, etc all behave just like a data.frame.  There are two differences.  One you can see the header at the top.  It contains the projection information which tells you what the coordinate system is.  The second is the 'geometry' column.  Those are the simple features and in this case they contain all the information necessary to draw a well survey.  Because of that, we store the information for one well in only one line of a table!  No more needlessly repeating data hundreds of time because there's hundreds of rows in a directional survey... not like I'd ever do anything like that...

Anyway, one of the first things you need to do when working with spatial data is get everything on the appropriate projections.  We can see what projections are like this:

```{r, check projections}
st_crs(wells)$input
```

We can see they're in UTM Zone 13 NAD83.  Let's convert to Colorado Central State Plane coordinates.  To do that we need to need to know the EPSG number of the projection.  I usually look them up on [spatialreference.org](https://spatialreference.org/).  After that we use the appropriately named st_transform function.

```{r, transform coordinates}
wells = st_transform(wells, 26754)
```

Now, let's look at one well.  But not just any well of course.  Let's find the longest horizontal.  We can get the length of each feature with the st_length command.  Then we can use which.max to tell us the index of the longest one.  We'll plot with the plot function which is available in base R.

```{r, plot well}
longest_well_index = which.max(st_length(wells))
plot(wells[longest_well_index, 'geometry'])
```

Looks like a number one!  Also looks like it's part of a pad.  How do we find its padmates?  If only we had some way to find the wells within a certain distance of another well...  For that, we'll use a couple functions.  First, the st_buffer function to make a polygon a mile around the well.

```{r, make buffer}
buffer = st_buffer(wells[longest_well_index,], dist=5280)
plot(buffer$geometry)
plot(wells[longest_well_index,'geometry'], add=TRUE, col='red')
```

Then we can use st_intersects to find the other wells that intersect that polygon.

```{r, get padmates}
ints = st_intersects(buffer, wells)
ints
```

st_intersects outputs a list the same length as the first argument.  Each element of list contains the indices of the other argument that intersect the first.

```{r, plot padmates}
plot(buffer$geometry)
plot(wells[ints[[1]], 'geometry'], add=TRUE, col='green')
plot(wells[longest_well_index,'geometry'], add=TRUE, col='red')
```

Excellent.  What if we want to drill our own pad?  We can make our own features like this.  First we'll make the coordinates of the new wells using the offset well like this.  Basically we're just making a little dataframe with a start and end point for three locations.  They also have id's to tell us which points belong to which well.

```{r, make wells}
longest_well_coords = st_coordinates(wells[longest_well_index,])
max_x = max(longest_well_coords[,1])
min_x = longest_well_coords[which.max(longest_well_coords[,2]),1]
min_y = min(longest_well_coords[,2])
max_y = max(longest_well_coords[,2])
x = c(max_x + 660, min_x + 660, max_x+1320, min_x+1320, max_x+1980, min_x+1980)
y = c(min_y, max_y, min_y, max_y, min_y, max_y)
id = rep(1:(length(x)/2), each = 2)
coords = data.frame(x,y,id)
coords
```

Then  we'll turn them into simple features using st_linestring and lapply.  Finally we'll set the coordinate reference system to be the same as the existing wells using st_crs. 

```{r, make well sf}
g = lapply(unique(id), function(i) st_linestring(as.matrix(coords[coords$id==i,c('x','y')])))
g = st_sf('geometry' = st_sfc(g))
st_crs(g) = st_crs(wells)

plot(buffer$geometry)
plot(wells[ints[[1]], 'geometry'], add=TRUE, col='green')
plot(wells[longest_well_index,'geometry'], add=TRUE, col='red')
plot(g$geometry, add=TRUE, col='purple')
```

If we want to add our new locations to the wells we can use sf:::rbind.sf.  Although, we have to make sure they have the same number of columns first.

```{r, join locs to wells}
g[,names(wells)[!(names(wells) %in% 'geometry')]]=NA
wells = sf:::rbind.sf(wells, g)
```

Now what if we want only the parts of the wells inside the buffer?  For that, we use st_intersection.  We'll check again which wells intersect our buffers first so we capture our newly created wells.

```{r, get intersection}
ints = st_intersects(buffer, wells)
wellInts = st_intersection(wells[ints[[1]],], buffer$geometry)
plot(buffer$geometry)
plot(wells[ints[[1]], 'geometry'], add=TRUE, col='green')
plot(wells[longest_well_index,'geometry'], add=TRUE, col='red')
plot(wellInts$geometry, add=TRUE, col='blue')
```

Don't worry about the warning.  When it intersects things it assumes that the other columns can be propagated from the first argument to the second.  It's just telling you that it's doing that.  If you don't want them to, then just limit the number of columns.

Anyway, now if we want to know the total length of offset wellbore within that polygon we can simply calculate the lengths and sum the up like so.  We'll divide by the average length of the intersected wells to turn it into more of a well density.

```{r, get length}
wellInts$length = as.numeric(st_length(wellInts))
length = sum(wellInts$length, na.rm=TRUE)
density = length/mean(wellInts$length, na.rm=TRUE)
density
```

But who just wants to know the density of just one well?!  Let's loop them all... well most of them anyway.  Using full directional surveys to do this is pretty intensive, so I'm just going to limit this to Wattenberg horizontals.  We'll also use st_simplify to reduce the number of points using a 20' tolerance.  Even then it takes awhile on my slow laptop (10 min or so).  I usually use two point well sticks and parLapply to speed things up, but in the name of simplicity let's just do this the slow way.

```{r, make density map, cache=TRUE}
wells = wells[wells$Deviation=='Horizontal' & !is.na(wells$Deviation), ]
wells = wells[wells$Field_Name=='WATTENBERG', ]
wells = st_simplify(wells, dTolerance = 20)
buffers = st_buffer(wells, dist=2640)
ints = st_intersects(buffers, wells)
getDensity = function(buffer, wellSubset){
  wInt = suppressWarnings(st_intersection(buffer, wellSubset))
  wInt$intersected_length = as.numeric(st_length(wInt))
  density = sum(wInt$intersected_length, na.rm=TRUE)/mean(wInt$intersected_length, na.rm=TRUE)
}
density = lapply(1:nrow(buffers), function(i) getDensity(buffers[i,], wells[ints[[i]],]))
density = do.call(c, density)
wells$density = density
plot(wells[,'density'])
```

And that's pretty much it!  There's obviously a lot more you can do, but hopefully that's enough to get you started exploring the sf package and automating some spatial tasks.